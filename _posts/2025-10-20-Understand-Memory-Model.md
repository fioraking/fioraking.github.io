# Memory Model

从多线程的角度出发，A线程中对共享变量的访问和修改，对其他线程来说是怎么样的，我们需要定义一种模型来描述这种“怎么样”，这个模型就是Memory Model，它是硬件提供给软件的模型，应用开发人员仅需要了解内存模型就可以对在多线程中解决共享变量的问题。
+ 硬件定义了一套内存一致性模型来去解决对程序员的承诺。

+ 内存序是对内存一致性模型的具体实现。

+ 缓存一致性是支撑内存排序的硬件基础。
 

其实也就是软件开发人员和硬件开发人员对多线程(多核)之间的共享变量(内存)的可见性和顺序性的协议。 

+ 可见性就是共享变量更改什么时候对其他线程可见。
+ 顺序性就是共享变量的在A核中读写顺序在其他核看来是不是和A核的一致。

硬件开发人员定义了一套内存一致性模型来去描述顺序性和可见性？看一下内存一致性模型。
# Memory Consistency
## SC（Sequential consistency）
可见性是其他核立即可见。
顺序性是其他核见到的一致。 
也就是大多程序员理解的那样，符合直觉。

 
执行顺序上只可能是S1-> L1, S2->L2, 至于S1还是S2先执行无所谓，但可定是S1先于L1, S2先于L2, 并且对C1对x的修改, C2立即可见。
S1L1 S2L2 
所以不会出现程序执行完之后，r1=0, r2=0;

Lamport（在1970年）提出:
一个多核系统遵循顺序一致性”当且仅当“多进程的执行结果和把这几个进程的指令按某种顺序排成一列然后按序执行的结果相同，并且这一列中任一单进程的指令都遵循在原进程中的先后顺序（拓扑序列）， 也就是硬件向软件保证硬件会按照这种模型输出内存访问的结果。

形式化定义：
 
第一个意思：如果load a在程序顺序中在load b之前，那么在SC模型所允许的内存顺序中，load a也肯定在load b之前。

在内存顺序中A在B之前，指“A对内存施加影响”发生在“B对内存施加影响”之前。所谓“施加影响”就是改变内存状态，例如，对于store而言，施加影响就是指把数据写入到内存中，并且所有处理器核都能从内存中看到这个新数据。
 
其中Max<m{}是指定义域中内存顺序最靠后的指令，用语言来描述这条规则就是：load a必须返回内存顺序里“在它之前且离它最近”的store a的结果。
这个等式实际上就和上文说的“对内存施加完影响”是一个意思。


问题：性能很差

## TSO （Total store ordering）
针对store-load，
顺序性：其他核看到的不一样
可见性：其他核看到的不一样
其他和SC模型一致。

为了优化store性能，诞生了一种结构，write buffer。
 
在SC的基础上，加入write buffer结构，store指令在提交时从store buffer转移到write buffer，然后硬件择机把write buffer中的数据写到cache/内存中。 这种情况导致硬件在某些情况下，打破了SC的模型顺序。
 
比如这个，即使处理器保证S1->L1, S2->L2, 也1有可能出现r1=0,r2=0;
因为S1,S2在Write buffer中但是还没产生内存影响时。如这个序列：S1S2L1L2, 
执行到L1时，由于S2还在write buffer当中，还没产生内存影响，所以r1=0,L2也是同理。

此时和软件开发人员所理解的SC模型不同了，多线程程序有时候会出现莫名其妙的错误。
因为他们认为不会出现r1=0,r2=0这种情况。但是因为有write buffer的存在，store-load这种情况就出现了。

 
硬件保证不了第四种情况了。

硬件开发人员为了避免这种情况的出现，提供了一种工具，这种工具帮助软件开发人员在TSO模型下模拟SC，这种工具就是内存屏障(FENCE指令)。
关于FENCE指令的功能：在单一进程中，只有FENCE之前的所有存储指令都执行完（对内存施加完影响）之后，FENCE之后的存储指令才会被发射到执行单元中。顾名思义，FENCE指令对存储指令就像是栅栏一样，栅栏后的指令全被拦住，直到栅栏前面空空如也。

 
对于这个就是Store-load的情况，在S1 L1 中间加入 FENCE, S2 L2中间加入FENCE。就模拟了SC模型。 软件开发人员又能按照SC那样编写多线程程序了。

形式化定义还要再加上：
 
这个修改是load的返回值不再一定等于内存顺序中紧靠在它之前的store，而是可能是这个store的值，也可能是同一核心内处于write buffer中的store的值，并且write buffer中的store优先级高于内存顺序中的store。

 

## Relax consistency 
SC模型和TSO模型一般也被称为强一致性模型，之所以说“强”，是因为这两个模型约束所有或者绝大部分存储指令的顺序（SC模型约束所有存储指令的顺序，TSO约束除store-load之外的所有顺序）。而这种“强一致性”是靠牺牲硬件性能获得的，最简单的一点，这两个模型都要求处理器核顺序执行自己的存储指令，这种要求没有充分利用乱序执行技术，为了充分利用乱序执行技术（以及一切可能的技术）， 考虑放松所有约束，但是也会提供模拟SC模型的工具，这种工具也是FENCE指令。

SC/TSO带来的性能损失：
 
没有必要约束S1->S2(store->store), 如果S1阻塞，S2执行不了。
 
没有必要约束临界区的代码的访存关系，因为C2只有等C1的所有内存访问生效才能访问。

形式化定义：
 
这组约束关系保证程序员拥有强制约束关系的能力
 
这组约束关系是单核顺序性的必然要求。
 
这个等式和TSO模型相同，这也是保护单核顺序性的必然要求。




























### Relax 模型下模拟SC:
 
不加入FENCE，可能导致r2=0,r3=0;因为完全没了约束，即硬件不会保证顺序执行。
硬件可能会这样重排：C1: S3 S1 S2;
时间顺序上可能是 S3 L1 B1 L2 L3 S1 S2, （硬件视情况而定完全有可能出现这种情况）
 
临界区内的代码不能越过获取锁和释放锁。 










## RC (Release consistency )
对于relax模型可以再次优化。
1.	F11 F14 F21 F24 可以去掉，没有必要。
2.	临界区内的代码不能越过获取锁和释放锁。 但是其实临界区外的代码能越过获取锁和释放锁，也就是扩大临界区范围，如果硬件有利可图的话。

FENCE指令是双向禁止，可以将其变为单向的，允许单向通过。

形式化约束描述：
Acquire -> Load , Store 
Load, Store -> Release
Acquire -> Acquire
Acquire -> Release
Release -> Acquire
Release -> Release




























# Memory Ordering
是描述多线程环境下内存操作可见性和顺序性的规则体系，本质上是硬件和编译器之间的契约。

# Cache Consistency
缓存一致性（Cache Coherence）解决的是多核系统中各处理器缓存数据副本的同步问题，其解决方案本质是通过硬件协议实现自动化的状态同步。
1.	自动同步但有延迟
2.	缓存行是同步单位
3.	架构差异影响代码

缓存一致性协议确保硬件层面的数据副本最终同步(并不是立即可见)，但：
1.	需要原子操作/内存屏障保证操作原子性
2.	DMA等外设访问需要显式缓存控制
3.	不同架构的同步粒度和时序存在差异
4.	编程模型仍需处理内存序问题
这种同步机制使得在多核编程中，开发者可以像单核环境一样思考数据访问，而无需手动管理每个缓存副本的状态，但必须理解底层协议的可见性边界。

 
# Concept
1.	内存一致性模型（Memory Consistency Model）
•	定义处理器对内存操作的可见性规则
•	描述多核系统中不同线程看到的内存操作顺序
•	常见模型：顺序一致性（SC）、总存储序（TSO）、弱一致性（ARM/POWER）
•	示例：x86的TSO模型允许store buffer存在，导致写操作对本地核心立即可见，对其他核心延迟可见
2.	内存排序（Memory Ordering）
•	实现内存一致性模型的具体约束规则
•	控制指令重排序的边界和限制
•	包括：Load-Load、Load-Store、Store-Load、Store-Store四种可能的乱序组合
•	示例：ARM的dmb指令、x86的mfence指令
3.	内存模型（Memory Model）
•	更广泛的概念，包含一致性模型和内存排序
•	定义整个内存系统的行为规范
•	包括：缓存一致性协议、内存访问原子性、可见性保证等
•	示例：C++内存模型、Java内存模型
4. 缓存一致性
•	目标：保证多核系统中所有处理器缓存的数据副本一致性
•	解决单地址的写入可见性问题
•	硬件自动维护的协议（MESI/MOESI等）
•	典型问题：防止两个核心同时修改同一缓存行导致数据不一致






















## C++ Memory Model
``` 
是否需要原子操作？
├─ 是 → 是否需要严格顺序？
│   ├─ 是 → 使用seq_cst（默认安全）
│   └─ 否 → 操作类型判断：
│       ├─ 加载操作 → acquire
│       ├─ 存储操作 → release
│       └─ RMW操作 → acq_rel
└─ 否 → 使用mutex/lock等同步原语
```

 




 









# 误解
TSO Store-load重排
开发者视角的真相
•	指令在本核始终按程序顺序执行
•	"重排"是其他核观察到的内存操作顺序与程序顺序不一致
•	这种不一致源于：
o	Store Buffer的异步刷新机制
o	缓存一致性协议的传播延迟
o	内存子系统的并行优化

+ x86的"Store-Load重排"实质是内存操作可见性顺序与程序顺序的差异，而非真正改变指令执行顺序。这是TSO模型通过Store Buffer实现性能优化的副作用，与ARM等弱内存模型中真正的指令重排有本质区别。








































# TSO 测试
```
#include <iostream>
#include <thread>
int x,y,r1,r2;

void thread1() {
    x = 13;
    r1 = y;
}

void thread2() {
    y = 14;
    r2 = x;
}

int main() {
    const int iterations = 1000000;
    int count = 0;

    for (int i = 0; i < iterations; ++i) {
        r1 = r2 = 1;
        x = y = 0;
        std::thread t1(thread1);
        std::thread t2(thread2);
        
        t1.join();
        t2.join();
        
        if (r1 == 0 && r2 == 0) {
            ++count;
        }
    }

    std::cout << "r1 = 0 and r2 = 0 occurred " << count << " times out of " << iterations << " iterations.\n";

    return 0;
}
```
由于write buffer硬件的存在就会出现
```
 ./a.out 
r1 = 0 and r2 = 0 occurred 2 times out of 1000000 iterations.
```

# 参考
【计算机体系结构】内存一致性 - 天外飞仙的文章 - 知乎
https://zhuanlan.zhihu.com/p/694673551

 
