字节序与大小端
# 1.	字节序（endianness）
对于0x12345678这个十六进制数据
+ 二进制为：00010010 00110100 01010110 01111000
有两种字节序
1）	从左到右
```
0x12 0x34 0x56 0x78
```
2）	从右到左
```
0x78 0x56 0x34 0x12
```
它是byte order不是bit order
所以不会出现
```
0x21 0x43 0x65 0x87
0x87 0x65 0x43 0x21
```
这这种情况。
也就是说，字节内部的bit顺序不会变，变的只是字节序。
# 2.	大小端
现在把这个数据【0x12345678】存储到内存中，并且加载到寄存器中。
有3个问题：
1）	内存中如何存储
2）	如何加载到寄存器中
3）	加载之后寄存器中是什么样子
LSB: Least Significant Byte
MSB: Most Significant Byte
【1】存储到内存中
+ 小端：数据低字节存储到内存低地址 LSB=>low memory address
```
0001	0x78
0002	0x56
0003	0x34
0004	0x12
```
+ 大端：数据低字节存储到内存高地址 MSB=>low memory address
```
0001	0x12
0002	0x34
0003	0x56
0004	0x78
```
【2】如何加载到寄存器（存疑，合理推测结果）
小端：从内存低字节开始读，读到寄存器低位
大端：从内存低字节开始读，读到寄存器高位

【3】加载到寄存器之后的值
小端: 加载到寄存器之后,值为0x12345678
大端: 加载到寄存器之后,值为0x12345678
对于基本数据类型而言，虽然存储到内存中的字节序不一样，但是load进寄存器的最终值都是一样的。

# 字符串
字符串按照字节存储，无论是中文还是英文字符，和字节序无关。
C源码：
 TODO
反汇编：
TODO
# Bit-field
对于位域的存储：位域的域段都是从低地址开始存储,无论是大端还是小端。
按照下面的例子，即以a,b,c,d的顺序逐次存储，先a后b之后c，a永远存储在低地址，b次之，以此类推。
大小端的区别是：
小端在一个字节内部遵守低地址低比特位，大端是低字节高比特位。
可以看下面的例子。

TODO







```
C源码：
struct bf{
    int a:3;
    int b:4;
    int c:5;
    int d:20;
};
struct bf tmp = {0x01, 0x02, 0x03,0x04}; 
原码                      0010 0100, 0011 0000, 0000 0000, 0000 0100     
小端:0x91410000         1001 0001, 0100 0001, 0000 0000, 0000 0000 （内存）
低地址加载到reg低字节  0000 0000, 0000 0000, 0100 0001, 1001 0001  （寄存器）

原码                     0010 0100, 0011 0000, 0000 0000, 0000 0100           
大端:0x24300004        0010 0100, 0011 0000, 0000 0000, 0000 0100 （内存）


反汇编：
使用riscv64-unknown-linux-gnu-gcc验证。我们的clang与其保持一致。
 

Unused bit-field
C源码：
struct bf{
    int a:3;
    int b:4;};
struct bf tmp = {0x01, 0x02}; 
 
0010,0100,0000,0000,0000,0000,0000,0000
可以看到未使用的域段为0.
总结
C定义的位域：
struct bf{
    int a:3;
    int b:4;
    int c:5;
    int d:20;
};
在寄存器中：
小端：a=>d, 对应LSB=>MSB
大端：a=>d, 对应MSB=>LSB
```
# 参考
https://zhuanlan.zhihu.com/p/715356841
以及编译器验证
